---

# number-sets are a little messy in that the base was converted to a number-set, so we have to match that (simple) case last
- name: pos-neg-number-sets
  tag: number-sets
  match: "count(*)=2 and *[2][text()='+' or text()='-']"
  replace:
  - bookmark: "*[2]/@id"
  - test:
    - if: "*[2][text()='+']"
      then: [T: "正"]      # phrase(小于 10 的所有'正'整数的集合)
      else: [T: "负"]      # phrase(小于 -10 的所有'负'整数的集合)
  - bookmark: "*[1]/@id"
  - test:
    - if: "*[1][text()='ℂ']"
      then: [T: "复数"]      # phrase('复数'包括实部和虚部两部分)
    - else_if: "*[1][text()='ℕ']"
      then: [T: "自然数"]      # phrase('自然数'又叫做非负整数)
    - else_if: "*[1][text()='ℚ']"
      then: [T: "有理数"]      # phrase('有理数'是两个整数的分数)
    - else_if: "*[1][text()='ℝ']"
      then: [T: "实数"]      # phrase('实数'可以分为有理数和无理数两类)
    - else_if: "*[1][text()='ℤ']"
      then: [T: "整数"]      # phrase('整数'由负整数、0 和正整数组成)
      else: [x: "*[1][text()]"] # shouldn't happen

- name: dimension-number-sets

  # should be single digit integer at this point (e.g, R^3)
  tag: number-sets
  match: "count(*)=2"
  replace:
  - bookmark: "*[1]/@id"
  - test:
    - if: "*[1][text()='ℂ']"
      then: [T: "C"]      # phrase(the letter 'C' used to represent complex number)
    - else_if: "*[1][text()='ℕ']"
      then: [T: "N"]      # phrase(the letter 'N' may represent natural numbers)
    - else_if: "*[1][text()='ℚ']"
      then: [T: "Q"]      # phrase(the letter 'Q' may represent rational numbers)
    - else_if: "*[1][text()='ℝ']"
      then: [T: "R"]      # phrase(the letter 'R' may represent real numbers)
    - else_if: "*[1][text()='ℤ']"
      then: [T: "Z"]      # phrase(the letter 'Z' may represent integers)
      else: [x: "*[1][text()]"] # shouldn't happen
  - bookmark: "*[2]/@id"
  - x: "*[2]"

- name: simple-number-sets
  tag: number-sets
  match: "count(*)=0"
  replace:
  - bookmark: "@id"
  - test:
    - if: "text()='ℂ'"
      then: [T: "复数"]      # phrase('复数'包括实部和虚部两部分)
    - else_if: "text()='ℕ'"
      then: [T: "自然数"]      # phrase('自然数'又叫做非负整数)
    - else_if: "text()='ℚ'"
      then: [T: "有理数"]      # phrase('有理数'是两个整数的分数)
    - else_if: "text()='ℝ'"
      then: [T: "实数"]      # phrase('实数'可以分为有理数和无理数两类)
    - else_if: "text()='ℤ'"
      then: [T: "整数"]      # phrase('整数'由负整数、0 和正整数组成)
      else: [x: "text()"] # shouldn't happen

- name: real-part
  tag: real-part
  match: "."
  replace:
  - bookmark: "@id"
  - t: "实际部分"      # phrase('the real part' of a complex number does not include the imaginary part)

- name: imaginary-part
  tag: imaginary-part
  match: "."
  replace:
  - bookmark: "@id"
  - t: "假想部分"      # phrase('the imaginary part' is part of a complex number)

# rules on scripted vertical bars ('evaluated at')
- name: evaluated-at-2
  tag: evaluate
  match: "count(*)=2"
  replace:
  - x: "*[1]"
  - pause: auto
  - t: "评估"      # phrase(results were 'evaluated at' a given point)
  - pause: auto
  - x: "*[2]"

- name: evaluated-at-3
  tag: evaluate
  match: "count(*)=3"
  replace:
  - x: "*[1]"
  - pause: auto
  - t: "评估"      # phrase(results were 'evaluated at' this point)
  - pause: auto
  - x: "*[3]"
  - t: "减去在"      # phrase(this result is 'minus the same expression evaluated at' an earlier point)
  - x: "*[2]"

- name: binomial
  tag: binomial
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - T: "从"      # phrase('从' 5 选择 2 项)
  - x: "*[1]"
  - T: "选择"      # phrase(从 5 '选择' 2 项)
  - x: "*[2]"
  - T: "项"      # phrase(从 5 选择 2 '项')

- name: permutation
  tag: permutation-symbol
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - x: "*[2]"
  - T: "排列"      # phrase(从n个不同元素中取出r个元素的'排列'数)
  - x: "*[1]"

- name: intervals
  tag: [open-interval, open-closed-interval, closed-interval, closed-open-interval]
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then:
      - t: "这"      # phrase('the' square root of 25 equals 5)
  - x: "translate(name(.),'-', ' ')"
  - test:
      if: "$Verbosity!='Terse'"
      then:
      - t: "从"      # phrase(subtracting 5 'from' 10 gives 5)
      - x: "*[1]"
      - t: "添加到"      # phrase(adding 6 'to' 6 equals  12)
      - x: "*[2]"
      else:
      - x: "*[1]"
      - t: "逗号"      # phrase(use a 'comma' to divide large numbers or as a decimal point)
      - x: "*[2]"

- name: default-point
  tag: point
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then:
      - t: "这"      # phrase('the' square root of 25 equals 5)
  - t: "点"      # phrase(a decimal 'point' indicates the fraction component of a number)
  - x: "*[1]"
  - t: "逗号"      # phrase(use a 'comma' to divide large numbers or as a decimal point)
  - x: "*[2]"

- name: absolute-value
  tag: absolute-value
  match: "count(*)=1 and not(@data-intent-property)"
  replace:
  - test:
      if: "$Verbosity='Terse'"
      then: [t: "绝对值"]      # phrase(the 'absolute value' of a number represents its distance from 0)
      else: [t: "绝对值"]      # phrase('the absolute value of' a number represents its distance from 0)
  - x: "*[1]"
  - test:
      if: "IsNode(*[1], 'leaf') or $Impairment != 'Blindness'"
      then: [pause: short]
      else: [pause: short, t: "最终绝对值", pause: short]      # phrase(show 'end absolute value' position)

- name: negative
  tag: negative
  match: "count(*)=1 and not(@data-intent-property)"
  replace:
  - bookmark: "./@id"
  - t: "负"      # phrase('negative' numbers are those less than 0)
  - x: "*[1]"

- name: positive
  tag: positive
  match: "count(*)=1 and not(@data-intent-property)"
  replace:
  - bookmark: "./@id"
  - t: "正"      # phrase(multiplying two negatives results in a 'positive' number)
  - x: "*[1]"

- name: subscript
  tag: sub
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - x: "*[1]"
  - t: " sub"      # phrase(the subscripted variable a 'sub' i)
  - x: "*[2]"
  - test:
      if: "not(IsNode(*[2],'leaf')) and $Impairment = 'Blindness'"
      then:
      - test:
          if: "$Verbosity='Verbose'"
          then: [t: "最终下标"]      # phrase(this is the 'end subscript' position)
          else: [t: "最终子"]      # phrase(this is the 'end sub' position)
  - pause: short

- name: bigop-both
  tag: large-op
  match: "count(*) = 3"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then: [t: "这"]      # phrase('the' square root of 25 equals 5)
  - x: "*[1]"
  - t: "从"      # phrase(subtracting 5 'from' 10 gives 5)
  - x: "*[2]"
  - t: "添加到"      # phrase(adding 6 'to' 6 equals  12)
  - x: "*[3]"
  - test:
      if: "following-sibling::*"
      then: [t: "的"]      # phrase(the square root 'of' 25 equals 5)

- name: bigop-under
  tag: large-op
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then: [t: "这"]      # phrase('the' square root of 25 equals 5)
  - x: "*[1]"
  - t: "超过"      # phrase(2 'over' 3 equals two thirds)
  - x: "*[2]"
  - test:
      if: "following-sibling::*"
      then: [t: "的"]      # phrase(the square root 'of' 25 equals 5)

- name: largeop
  tag: mrow
  match: "count(*)=2 and IsInDefinition(*[1], 'LargeOperators')"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then: [t: "这"]      # phrase('the' square root of 25 equals 5)
  - x: "*[1]"
  - t: "的"      # phrase(the square root 'of' 25 equals 5)
  - x: "*[2]"

- name: limit
  tag: limit
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - test:
      if: "$Verbosity!='Terse'"
      then: [t: "x接近1的"]           # phrase('the' limit as x approaches 1)
  - test:
    - if: "*[1][.='lim']"
      then: [t: "限制"]
    - else_if: "*[1][.='limsup']"
      then_test:
          if: "$Verbosity='Terse'"
          then: [t: "lim sup"]
          else: [t: "限制优越"]
    - else_if: "*[1][.='liminf']"
      then_test:
          if: "$Verbosity='Terse'"
          then: [t: "lim inf"]
          else: [t: "限制较低"]
    - else: [x: "*[1]"]
  - t: "as"                      # phrase(the limit 'as' x approaches 1)
  - x: "*[2]"
  - pause: short

- name: vector
  tag: modified-variable
  match: "count(*)=2 and *[2][text()='→']"
  replace:
  - t: "向量"      # phrase(the 'vector' reflects size and direction)
  - x: "*[1]"

- name: default

  tag: modified-variable
  match: "count(*)=2 and not(@data-intent-property)"
  replace:
  - x: "*[1]"
  - x: "*[2]"
  - pause: short

- name: default
  # handles single, double, etc., prime
  tag: [skip-super, say-super]
  match: "count(*)=2"
  replace:
  - x: "*[1]"
  - test:
      if: "name(.)='say-super'"
      then_test:
        if: "$Verbosity='Terse'"
        then: [t: "超级"]      # phrase(this is a 'super' set of numbers)
        else: [t: "上标"]      # phrase(a 'superscript' number indicates raised to a power)
  - x: "*[2]"
  - pause: short

- name: msubsup-skip-super
  # handles single, double, etc., prime
  tag: [skip-super, say-super]
  match: "count(*)=3"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity='Verbose'"
      then: [t: "下标"]      # phrase(a 'subscript' may be used to indicate an index)
      else: [t: "子"]      # phrase(the result is 'sub' optimal)
  - x: "*[2]"
  - test:
      if: "not(IsNode(*[2],'leaf') and $Impairment = 'Blindness')"
      then:
      - test:
          if: "$Verbosity='Verbose'"
          then: [t: "最终下标"]      # phrase(this is the 'end subscript' position)
          else: [t: "最终子"]      # phrase(this is the 'end sub' position)
      - pause: short
      else_test:
          if: "*[2][self::m:mi]"   # need a pause in "x sub k prime" so the prime is not associated with the 'k'
          then: [pause: short]
  - test:
      if: "name(.)='say-super'"
      then_test:
        if: "$Verbosity='Verbose'"
        then: [t: "上标"]      # phrase(a 'superscript' number indicates raised to a power)
        else: [t: "超级"]      # phrase(this is a 'super' set of numbers)
  - x: "*[3]"
  - pause: short

- name: sin
  tag: mi
  match: "text()='sin'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Verbose'"
      then: [T: "正弦"]      # phrase('正弦' theta 是角 θ 的正弦值)
      else: [T: "sine"]      # phrase('sine' theta 是角 θ 的正弦值)
- name: cos
  tag: mi
  match: "text()='cos'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity='Terse'"
      then: [T: "cos"]      # phrase('cos' theta 是角 θ 的余弦值)
    - else_if: "$Verbosity='Verbose'"
      then: [T: "余弦"]      # phrase('余弦' theta 是角 θ 的余弦值)
    - else: [T: "cosine"]      # phrase('cosine' theta 是角 θ 的余弦值)
- name: tan
  tag: mi
  match: "text()='tan' or text()='tg'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity='Terse'"
      then: [T: "tan"]      # phrase('tan' theta 是角 θ 的正切值)
    - else_if: "$Verbosity='Verbose'"
      then: [T: "正切"]      # phrase('正切' theta 是角 θ 的正切值)
    - else: [T: "tangent"]      # phrase('tangent' theta 是角 θ 的正切值)
- name: sec
  tag: mi
  match: "text()='sec'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity='Terse'"
      then: [T: "sec"]      # phrase('sec' theta 是角 θ 的正割值)
    - else_if: "$Verbosity='Verbose'"
      then: [T: "正割"]      # phrase('正割' theta 是角 θ 的正割值)
    - else: [T: "secant"]      # phrase('secant' theta 是角 θ 的正割值)
- name: csc
  tag: mi
  match: "text()='csc'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity='Terse'"
      then: [T: "cosec"]      # phrase('cosec' theta 是角 θ 的余割值)
    - else_if: "$Verbosity='Verbose'"
      then: [T: "余割"]      # phrase('余割' theta 是角 θ 的余割值)
    - else: [T: "cosecant"]      # phrase('cosecant' theta 是角 θ 的余割值)
- name: cot
  tag: mi
  match: "text()='cot'"
  replace:
  - bookmark: "@id"
  - test:
    - if: "$Verbosity='Terse'"
      then: [T: "cotan"]      # phrase('cotan' theta 是角 θ 的余切值)
    - else_if: "$Verbosity='Verbose'"
      then: [T: "余切"]      # phrase('余切' theta 是角 θ 的余切值)
    - else: [T: "cotangent"]      # phrase(co'tangent' theta 是角 θ 的余切值)

- name: sinh
  tag: mi
  match: "text()='sinh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "sinch"]      # phrase(单词 'sinch' 是 双曲正弦 hyperbolic sine 的缩写)
      else: [T: "双曲正弦"]      # phrase('双曲正弦'函数)
- name: cosh
  tag: mi
  match: "text()='cosh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "cosh"]      # phrase('cosh' 是双曲余弦 hyperbolic cosine 的缩写)
      else: [T: "双曲余弦"]      # phrase('双曲余弦'函数)
- name: tanh
  tag: mi
  match: "text()='tanh'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "tanch"]      # phrase('tanch' 是双曲正切 hyperbolic tangent 的缩写)
      else: [T: "双曲正切"]      # phrase('双曲正切'是一个数学函数)
- name: sech
  tag: mi
  match: "text()='sech'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "sheck"]      # phrase('sheck' 是双曲正割 hyperbolic secant 的简略读法)
      else: [T: "双曲正割"]      # phrase('双曲正割' 是一个数学函数)
- name: csch
  tag: mi
  match: "text()='csch'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "cosheck"]      # phrase('cosheck' 是双曲余割 hyperbolic cosecant 的简略读法)
      else: [T: "双曲余割"]      # phrase('双曲余割' 是一个数学函数)
- name: coth
  tag: mi
  match: "text()='coth'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [T: "cotanch"]      # phrase('cotanch' 是双曲余切 hyperbolic cotangent 的简略读法)
      else: [T: "双曲余切"]      # phrase('双曲余切'是一个数学函数)
- name: exponential
  tag: mi
  match: "text()='exp'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [t: " exp"]      # phrase('exp' means exponential function)
      else: [t: "指数"]      # phrase('exponential' function)
- name: covariance
  tag: mi
  match: "text()='Cov'"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity='Terse'"
      then: [t: " cov"]      # phrase('Cov' is shorthand for the covariance function)
      else: [t: "协方差"]      # phrase('covariance' function)

- # handle both log and ln
# and lg
  name: log
  tag: mrow
  variables: [log_is_simple: "IsNode(*[3],'simple')"]
  match:
  - "count(*)=3 and"
  - "*[1][self::m:mi][text()='log' or text()='ln' or text()='lg'] and"
  - "*[2][self::m:mo][text()='⁡']"
  replace:
  - bookmark: "*[1]/@id"
  - test:
      if: "$log_is_simple and $Verbosity !='Terse'"
      then:
      - x: "*[3]"
      - T: "的"
  - test:
    - if: "*[1][text()='log']"
      then_test:
        if: "$Verbosity='Terse'"
        then: [T: "log"]
        else: [T: "对数"]      # phrase(x 的'对数')
    - else_if: "*[1][text()='lg']"
      then_test:
        if: "$Verbosity='Terse'"
        then: [spell: "'lg'"]
        else: [T: "常用对数"]      # phrase(x 的'常用对数')
    - else_if: "*[1][text()='ln']"
      then_test:
        if: "$Verbosity='Terse'"
        then: [spell: "'ln'"]
        else: [T: "自然对数"]      # phrase(x 的'自然对数')
    - else:
      - x: "*[1]"
  - test:
      if: "not($log_is_simple) or $Verbosity = 'Terse'"
      then:
      - x: "*[3]"
      - pause: medium

- name: log-base
  tag: log-base
  match: "not(@data-intent-property)"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity!='Verbose'"
      then: [T: "对数"]      # phrase('对数' 3 为底 x)
      else: [T: "以"]      # phrase('以' 3 为底的对数 x)
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Verbose'"
      then: [T: "为底"]      # phrase(对数 3 '为底' x)
      else: [T: "为底的对数"]      # phrase(以 3 '为底的对数' x)

- name: log-base-power
  tag: log-base-power
  match: "not(@data-intent-property)"
  replace:
  - bookmark: "@id"
  - test:
      if: "$Verbosity!='Verbose'"
      then: [T: "对数"]      # phrase('对数' 3 为底 平方)
      else: [T: "以"]      # phrase('以' 3 为底的对数 平方)
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Verbose'"
      then: [T: "为底"]      # phrase(对数 3 '为底' 平方)
      else: [T: "为底的对数"]      # phrase(以 3 '为底的对数' 平方)
  - test:
      - if: "*[2][text()=2]"
        then: [T: "平方"]     
      - else_if: "*[2][text()=3]"
        then: [T: "立方"]
        else:  # don't bother with special cases as this isn't likely to happen
        - T: "的"      # phrase(对数 b 为底 '的' n 次方)
        - x: "*[2]"
        - T: "次方"      # phrase(对数 b 为底 的 n '次方')
  - pause: short

- name: multi-line
  #   that eliminates the need for the if: else_if: ...
  # IDEA:  set a variable with the word to say for the row (e.g., RowLabel = Row/Case/Line/...)
  tag: [cases, equations, lines]
  match: "."
  variables:
    # Wikipedia has some tables where all the entire first column is empty (e.g., https://en.wikipedia.org/wiki/List_of_trigonometric_identities)
  - LineCountTry: "count(*/*[1][count(*)=1 and *[1][@data-added!='missing-content']])"
  - LineCount: "IfThenElse($LineCountTry=0, count(*/*[1]), $LineCountTry)"
  replace:
  - x: "$LineCount"
  - test:
    - if: "self::m:cases"
      then: [t: "案例"]      # phrase(this is the first 'case' of three cases)
    - else_if: "self::m:equations"
      then: [t: "方程式"]      # phrase(this is the first 'equation' of three equations)
      else: [t: "线"]      # phrase(this is the first 'line' of three lines)
  - test:
    - if: "$LineCount != 1"
      then: [ct: "s"] # plural
  - pause: short
  - x: "*"

- name: default-multiline
  tag: [mtr, mlabeledtr]
  match: "parent::m:cases or parent::m:equations or parent::m:lines"
  replace:
  - test:
      if: "parent::m:equations and *[1][count(*)=1 and *[1][@data-added='missing-content']] and
           count(*/*[1][count(*)=1 and *[1][@data-added!='missing-content']]) != 0"
      then:
      - t: "下线"
      else_test:
        if: "$LineCount != 1"
        then:
        - test:
          - if: "parent::m:cases"
            then: [t: "案例"]     # phrase('case' 1 of 10 cases)
          - else_if: "parent::m:equations"
            then: [t: "方程式"] # phrase('equation' 1 of 10 equations)
            else: [t: "线"]     # phrase('line 1 of 10 lines)
        - x: "count(preceding-sibling::*)+1"

  - test:
      if: .[self::m:mlabeledtr]
      then:
      - t: "标签"      # phrase(the diagram is complete 'with label')
      - x: "*[1]/*"
  - pause: medium
  - test:
      if: .[self::m:mlabeledtr]
      then: [x: "*[position()>1]"]
      else: {x: "*"}

- name: default-multiline
  tag: mtd
  match: "parent::*[parent::m:cases or parent::m:equations or parent::m:lines]"
  variables: [LongPause: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_MultiLinePausesBetweenColumns = 'Long'"]
  replace:
  - x: "*"
  - test:
    # short pause after each element; medium pause if last element in a row; long pause for last element in matrix unless ClearSpeak override
    - if: "count(following-sibling::*) > 0"
      then_test:
        if: "$LongPause"
        then: [pause: medium]
        else: [pause: short]
    - else_if: "count(../following-sibling::*) > 0"
      then_test:
        if: "$LongPause"
        then: [pause: long]
        else: [pause: medium]
      else: [pause: long]

# Matrix/Determinant rules
# matrix and determinant are the same other than "matrix"/"determinant" based on the bracketing chars
# the pausing logic is pushed down to the <mtd>
# the rules either speak the <mtr>s (to get "row n") or the <mtd>s. "column n" spoken if $IsColumnSilent is false
- name: 1x1-matrix
  tag: [matrix, determinant]
  variables: [IsColumnSilent: true()]
  match: "count(*)=1 and *[self::m:mtr][count(*) = 1]"
  replace:
  - ot: "这"      # phrase('the' 1 by 1 matrix M)
  - t: " 1 x 1"      # phrase(the '1 by 1' matrix)
  - test:
      if: "self::m:determinant" # just need to check the first bracket since we know it must be (, [, or |
      then: [t: "决定因素"]      # phrase(the 2 by 2 'determinant'))
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
      
  - t: "带入口"      # phrase(the 2 by 2 matrix 'with entry' x)
  - x: "*[1]/*"

# simpler reading methods for smaller matrices if the entries are simple
- name: 2-or-3x1-matrix
  tag: matrix
  variables: [IsColumnSilent: true()]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - "*[self::m:mtr][count(*) = 1] and " # one column
  - count(*)<=3 and # at least two rows
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  replace:
  - t: "这"      # phrase('the' 2 by 2 matrix M)
  - x: count(*)
  - t: "by 1列"      # phrase(the 2 'by 1 column' matrix)
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [t: "向量"]      # phrase(the 2 by 2 'vector')
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
  - pause: long
  - x: "*/*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - t: "结束"      # phrase('end' of matrix)
      - test:
          if: $ClearSpeak_Matrix = 'EndVector'
          then: [t: "向量"]      # phrase(the 2 column 'vector')
          else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')

- name: default-column-matrix
  tag: matrix
  variables: [IsColumnSilent: true()]
  match: "*[self::m:mtr][count(*) = 1]"
  replace:
  - t: "这"      # phrase('the' 2 by 2 matrix M)
  - x: "count(*)"
  - t: "by 1列"      # phrase(the 2 'by 1 column' matrix)
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [t: "向量"]      # phrase(the 2 column 'vector')
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
  - pause: long
  - x: "*" # select the rows (mtr)
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then: [t: "矩阵的结尾"]      # phrase(the 'end of matrix' has been reached)

- name: 1x2-or-3-matrix
  tag: matrix
  variables: [IsColumnSilent: "$SpeechStyle = 'SimpleSpeak' or ($SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix != 'SpeakColNum')"]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - count(*)=1  and # one row
  - count(*[1]/*)<=3 and # at least two cols
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  replace:
  - t: "1 by"      # phrase('the 1 by' 2 matrix)
  - x: count(*/*)
  - t: "排"      # phrase(the 1 by 4 'row' matrix)
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [t: "1 by"]      # phrase('the 1 by' 2 row 'vector')
      else: [t: "1 by"]      # phrase('the 1 by' 2 'matrix')
  - pause: long
  - x: "*/*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - t: "结束"      # phrase(the 'end' of matrix has been reached)
      - test:
          if: $ClearSpeak_Matrix = 'EndMatrix'
          then: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
          else: [t: "向量"]      # phrase(the 2 by 1 'vector')

- name: default-row-matrix
  tag: matrix
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix = 'SilentColNum'"]
  match: "count(*)=1" # one row
  replace:
  - t: "1 by"      # phrase('the 1 by' 2 matrix)
  - x: "count(*/*)"
  - t: "排"      # phrase(the 1 by 2 'row' matrix)
  - test:
      if: "$ClearSpeak_Matrix = 'Vector' or $ClearSpeak_Matrix = 'EndVector'"
      then: [t: "向量"]      # phrase(the 2 by 1 'vector')
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
  - pause: long
  - pause: medium
  - x: "*/*" # select the cols (mtd)
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - t: "结束"      # phrase(the 'end' of matrix has been reached)
      - test:
          if: $ClearSpeak_Matrix = 'EndMatrix'
          then: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
          else: [t: "向量"]      # phrase(the 2 by 1 'vector')

- name: simple-small-matrix
  tag: [matrix, determinant]
  match:
  - "$ClearSpeak_Matrix != 'SpeakColNum' and " # "simple" isn't used for this preference
  - (count(*)<=3 and count(*[1]/*)<=3) and # no bigger than a 3x3 matrix
  - IsNode(*/*/*,'simple') # IsNode() returns true if all the nodes are simple
  variables: [IsColumnSilent: "$SpeechStyle = 'SimpleSpeak' or ($SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix != 'SpeakColNum')"]
  replace:
  - t: "这"      # phrase('the' 1 by 2 matrix M)
  - x: count(*)
  - t: "by"      # phrase(the 1 'by' 2 matrix)
  - x: count(*[self::m:mtr][1]/*)
  - test:
      if: "self::m:determinant"
      then: [t: "决定因素"]      # phrase(the 2 by 2 'determinant')
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
  - pause: long
  - x: "*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - t: "结束"      # phrase(the 'end' of matrix has been reached)
      - test:
          if: "self::m:determinant"
          then: [t: "决定因素"]      # phrase(the 2 by 2 'determinant')
          else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')

- name: default-matrix
  tag: [matrix, determinant]
  variables: [IsColumnSilent: "$SpeechStyle = 'ClearSpeak' and $ClearSpeak_Matrix = 'SilentColNum'"]
  match: "not(@data-intent-property)"
  replace:
  - t: "这"      # phrase('the' 1 by 2 matrix M)
  - x: "count(*)"
  - t: "by"      # phrase(the 1 'by' 2 matrix)
  - x: "count(*[self::m:mtr][1]/*)"
  - test:
      if: "self::m:determinant"
      then: [t: "决定因素"]      # phrase(the 2 by 2 'determinant')
      else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix')
  - pause: long
  - x: "*"
  - test:
      if: "$ClearSpeak_Matrix = 'EndMatrix' or $ClearSpeak_Matrix = 'EndVector'"
      then:
      - t: "结束"      # phrase(the 'end' of matrix has been reached)
      - test:
          if: "self::m:determinant"
          then: [t: "决定因素"]      # phrase(the 2 by 2 'determinant')
          else: [t: "矩阵"]      # phrase(the 2 by 2 'matrix's)

- name: chemistry-msub

  tag: [chemical-formula]
  match: "*[1][text()='msub']"
  replace:
  - x: "*[2]"
  - test:
      if: "$Verbosity='Verbose'"
      then: [t: "下标"]      # phrase(H 'subscript' 2)
      else_test:
        if: "$Verbosity='Medium'"
        then: [t: "ub"]      # phrase(H 'sub' 2)
  - x: "*[3]"

- name: chemistry-msup
  tag: [chemical-formula]
  match: "count(*)=3 and *[1][text()='msup']"
  replace:
  - x: "*[2]"
  - test:
      if: "$Verbosity='Verbose'"
      then: [t: "superscript"]      # phrase(H 'superscript' 2)
      else_test:
        if: "$Verbosity='Medium'"
        then: [t: "super"]      # phrase(H 'super' 2)
  - x: "*[3]"
  - test:
      if: "following-sibling::*[1][text()='+' or text()='-']" # a little lazy -- assumes chemistry superscripts end with + or -
      then: [pause: medium]

-
  # There currently is no way to do sub/super for n-ary number of args
  # Instead, we just deal with up to two prescripts and up to four postscripts (repeating blocks of similar code [UGLY!])
  # This hopefully covers all reasonable cases...
  name: chemistry-scripts
  tag: [chemical-formula, chemical-nuclide]
  variables:
  # computing the number of postscripts is messy because of <mprescripts> being optionally present -- we use "mod" to get the count right
  - Prescripts: "m:mprescripts/following-sibling::*"
  - NumChildren: "count(*)" # need to stash this since the count is wrong inside '*[...]' below
  - Postscripts: "*[position()>1 and position() < (last() + ($NumChildren mod 2) -count($Prescripts))]"
  match: . # should only be msubsup or mmultiscripts at this point
  replace:
  - test:
      if: "$Prescripts" # we have at least one pre sub/super 
      then:
      # nuclide: speak the superscript first
      - test:
          if: "not($Prescripts[2][self::m:none])"
          then:
          - test:
              if: "$Verbosity='Verbose'"
              then: [t: "superscript"]      # phrase(H 'superscript' 2)
              else_test:
                if: "$Verbosity='Medium'"
                then: [t: "super"]      # phrase(H 'super' 2)
          - x: "$Prescripts[2]"
          - pause: "short"
      - test:
          if: "not($Prescripts[1][self::m:none])"
          then:
          - test:
              if: "$Verbosity='Verbose'"
              then: [t: "下标"]      # phrase(a 'subscript' may be used to indicate an index)
              else_test:
                if: "$Verbosity='Medium'"
                then: [t: "子"]      # phrase(here is a 'sub' total)
          - x: "$Prescripts[1]"
          - pause: "short"
      - test:
          if: "count($Prescripts) > 2" # can this happen for chemistry??? we allow for one *extra* pre sub/super pair
          then:
          - test:
              if: "not($Prescripts[4][self::m:none])"
              then:
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [t: "superscript"]      # phrase(H 'superscript' 2)
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [t: "super"]      # phrase(H 'super' 2)
              - x: "$Prescripts[4]"
              - pause: "short"
          - test:
              if: "not($Prescripts[3][self::m:none])"
              then:
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [t: "下标"]      # phrase(H 'subscript' 2)
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [t: "ub"]      # phrase(H 'sub' 2)
              - x: "$Prescripts[3]"
              - pause: "short"
  - x: "*[1]" # base
  - test:
      if: "$Postscripts"
      then:
      - test:
          if: "not($Postscripts[1][self::m:none])"
          then:
          - test:
              if: "$Verbosity='Verbose'"
              then: [t: "下标"]      # phrase(phrase(H 'subscript' 2)
              else_test:
                if: "$Verbosity='Medium'"
                then: [t: "ub"]      # phrase(phrase(H 'sub' 2)
          - x: "$Postscripts[1]"
          - pause: "short"
      - test:
          if: "not($Postscripts[2][self::m:none])"
          then:
          - test:
              if: "$Verbosity='Verbose'"
              then: [t: "superscript"]      # phrase(H 'superscript' 2)
              else_test:
                if: "$Verbosity='Medium'"
                then: [t: "super"]          # phrase(H 'super' 2)
          - x: "$Postscripts[2]"
          - pause: "short"
      - test:
          if: "count($Postscripts) > 2"
          then:
          - test:
              if: "not($Postscripts[3][self::m:none])"
              then:
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [t: "下标"]      # phrase(H 'subscript' 2)
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [t: "ub"]          # phrase(H 'sub' 2)
              - x: "$Postscripts[3]"
              - pause: "short"
          - test:
              if: "not($Postscripts[4][self::m:none])"
              then:
              - test:
                  if: "$Verbosity='Verbose'"
                  then: [t: "superscript"]      # phrase(H 'superscript' 2)
                  else_test:
                    if: "$Verbosity='Medium'"
                    then: [t: "super"]          # phrase(H 'super' 2)
              - x: "$Postscripts[4]"
              - pause: "short"
          - test:
              if: "count($Postscripts) > 4"
              then:
              - test:
                  if: "not($Postscripts[5][self::m:none])"
                  then:
                  - test:
                      if: "$Verbosity='Verbose'"
                      then: [t: "下标"]    # phrase(H 'subscript' 2)
                      else_test:
                        if: "$Verbosity='Medium'"
                        then: [t: "ub"]        # phrase(H 'sub' 2)
                  - x: "$Postscripts[5]"
                  - pause: "short"
              - test:
                  if: "not($Postscripts[6][self::m:none])"
                  then:
                  - test:
                      if: "$Verbosity='Verbose'"
                      then: [t: "superscript"]  # phrase(H 'superscript' 2)
                      else_test:
                        if: "$Verbosity='Medium'"
                        then: [t: "super"]      # phrase(H 'super' 2)
                  - x: "$Postscripts[6]"
                  - pause: "short"
              - test:
                  if: "count($Postscripts) > 6"
                  then:
                  - test:
                      if: "not($Postscripts[7][self::m:none])"
                      then:
                      - test:
                          if: "$Verbosity='Verbose'"
                          then: [t: "下标"]      # phrase(H 'subscript' 2)
                          else_test:
                            if: "$Verbosity='Medium'"
                            then: [t: "ub"]      # phrase(H 'sub' 2)
                      - x: "$Postscripts[7]"
                      - pause: "short"
                  - test:
                      if: "not($Postscripts[8][self::m:none])"
                      then:
                      - test:
                          if: "$Verbosity='Verbose'"
                          then: [t: "superscript"]      # phrase(H 'superscript' 2)
                          else_test:
                            if: "$Verbosity='Medium'"
                            then: [t: "super"]      # phrase(H 'super' 2)
                      - x: "$Postscripts[8]"
                      - pause: "short"
      - test:
          if: "$Postscripts[last()][not(self::m:none)] and following-sibling::*[1][text()='+' or text()='-']"
          then: [pause: medium]

- name: chemistry


  tag: chemical-equation
  match: "."
  replace:
  - x: "*"

- name: chemical-element
  tag: chemical-element
  match: "."
  replace:
  - bookmark: "@id"
  - spell: text()
  - pause: short

- name: chemical-state
  tag: chemical-state
  match: "count(*)=1"
  replace:
  - bookmark: "*[1]/@id"
  - test:
    - if: ".='s'"
      then: [t: "坚实"]      # phrase(Boron is a 'solid' in its natural state)
    - else_if: ".='l'"
      then: [t: "液体"]      # phrase(water is a 'liquid')
    - else_if: ".='g'"
      then: [t: "气"]      # phrase(hydrogen is a 'gas' )
      else: [t: "水性"]      # phrase(an 'aqueous' solution is contained in water)
  - pause: short

- name: chemical-formula-operator-bond
  tag: chemical-formula-operator
  match: "@data-chemical-bond"
  replace:
  # FIX: this might be better/more efficient if in unicode.yaml
  - bookmark: "@id"
  - test:
    - if: "text()='-' or text() = ':'"
      then: [t: "单键"]      # phrase(a 'single bond' is formed when two atoms share one pair of electrons)
    - else_if: "text()='=' or text() = '∷'"
      then: [t: "双键"]      # phrase(a 'double bond' may occur when two atoms share two pairs of electrons)
    - else_if: "text()='≡'"
      then: [t: "三键"]      # phrase(a 'triple bond' occurs when two atoms share three pairs of electrons)
    - else_if: "text()='≣'"
      then: [t: "四倍键"]      # phrase(a 'quadruple bond' occurs when two atoms share four pairs of electrons)
      else: [x: "text()"]

- name: chemical-formula-operator
  tag: chemical-formula-operator
  match: "."
  replace:
    x: "text()"

- name: chemical-arrow-operator
  tag: chemical-arrow-operator
  match: "."
  replace:
  # FIX: this might be better/more efficient if in unicode.yaml
  - bookmark: "@id"
  - test:
    - if: "DEBUG(.)='→' or .='⟶'"
      then_test:
        if: "$Verbosity='Terse'"
        then: [t: "形式"]      # phrase(hydrogen and oxygen 'forms' water )
        else: [t: "反应形成"]      # phrase(hydrogen and oxygen 'reacts to form' water)
    - else_if: ".='⇌' or .='\u1f8d2'"
      then: [t: "产品"]      # phrase(a reactant 'is in equilibrium with' a product)
    - else_if: ".='\u1f8d4'"
      then: [t: "处于左侧的平衡"]      # phrase(the reactant 'is in equilibrium biased to the left with' the product)
    - else_if: ".='\u1f8d3'"
      then: [t: "产品"]      # phrase(the reactant 'is in equilibrium biased to the right with' the product)
      else: [x: "*"]

- name: chemical-equation-operator
  tag: chemical-equation-operator
  match: "."
  replace:
  - bookmark: "@id"
  - x: "text()"

- name: none
  tag: none
  match: "../../*[self::m:chemical-formula or self::m:chemical-nuclide]"
  replace:
  - t: "" # don't say anything

- name: ignore-intent-wrapper
  tag: intent-wrapper
  match: "."
  replace:
  - x: "*"
