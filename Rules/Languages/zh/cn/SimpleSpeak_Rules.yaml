---

- name: intent-literal-silent
  tag: [mi, mo, mn]
  match: "contains(@data-intent-property, ':silent:')"
  # say nothing
  replace: []

# handling of negative numbers that come from 'intent' is hard -- we do something that is close to right here 
- name: intent-literal-negative-number
  tag: mn
  match: "starts-with(text(), '-')"
  replace:
  - T: "减去"        # phrase(x '减去' y)
  - x: "translate(text(), '-_', '')"

- name: default
  tag: square-root
  match: "."
  replace:
  - test:
      if: "IsNode(*[1], 'leaf') or $Impairment != 'Blindness'"
      then:
      - test:
          if: "$Verbosity!='Terse'"
          then: [T: "平方根"]   # phrase('平方根' x)
          else: [T: '根号']   # phrase('根号' x)
      - x: "*[1]"
      else:
      - T: "开"  # phrase('开' x 的平方根)
      - x: "*[1]"
      - T: "的平方根"  # phrase(开 x '的平方根')
  - pause: short

- name: default
  tag: root
  match: "."
  replace:
  - test:
      if: "not(IsNode(*[1], 'leaf')) and $Impairment = 'Blindness'"
      then:
      - T: "开"      # phrase('开' x + y 的五次方)
      - x: "*[1]"
      - test:
          if: "$Verbosity!='Terse'"
          then: [T: "的"]      # phrase(开 x + y '的' 五次方)
  - test:
      if: "*[2][self::m:mn and not(contains(., '.'))]"
      then_test:
      - if: "*[2][text()='2']"
        then: [T: "平方"]      # phrase(开 x + y 的 '平方')
      - else_if: "*[2][text()='3']"
        then: [T: "立方"]      # phrase(开 x + y 的 '立方')
      - else_if: "*[2][not(contains(., '.'))]"
        then: [x: "*[2]", T: "次方"]      # phrase(开 x + y 的 '5' '次方')
      else:
      - x: "*[2]"
      - T: "次方"      # phrase(开 x + y 的 N '次方')
  - test:
      if: "IsNode(*[1], 'leaf') or $Impairment != 'Blindness'"
      then: [T: "根", x: "*[1]"]   # phrase(4 次方 '根' x)
  - pause: short

# Fraction rules
# Commented unnecessary expressions in Chinese.
# Mixed numbers mostly "just work" because the invisible char reads as "and" and other parts read properly on their own
# - name: common-fraction
#   tag: fraction
#   match:
#   - "*[1][self::m:mn][not(contains(., '.')) and text()<20]   and"
#   - "*[2][self::m:mn][not(contains(., '.')) and 2<= text() and text()<=10]"
#   variables: [IsPlural: "*[1]!=1"]
#   replace:
#   - x: "*[1]"
#   - x: "ToOrdinal(*[2], true(), $IsPlural)"   # extra args specify fractional ordinal and whether it is plural

# - name: common-fraction-mixed-number
#   tag: fraction
#   match:
#   - "preceding-sibling::*[1][self::m:mo][text()='⁤'] and" # preceding element is invisible plus
#   - "*[1][self::m:mn][not(contains(., '.'))]   and"
#   - "*[2][self::m:mn][not(contains(., '.'))]"
#   variables: [IsPlural: "*[1]!=1"]
#   replace:
#   - x: "*[1]"
#   - x: "ToOrdinal(*[2], true(), $IsPlural)"   # extra args specify fractional ordinal and whether it is plural


- name: simple
  # don't include nested fractions. E.g, fraction a plus b over c + 1 end fraction" is ambiguous
  # by simplistic SimpleSpeak's rules "b over c" is a fraction, but if we say nested fractions
  # are never simple, then any 'over' applies only to enclosing "fraction...end fraction" pair.
  tag: fraction
  match:
  - "(IsNode(*[1],'leaf') and IsNode(*[2],'leaf')) and"
  - "not(ancestor::*[name() != 'mrow'][1]/self::m:fraction)" # FIX: can't test for mrow -- what should be used???
  replace:
  - x: "*[2]"
  - T: "分之"      # phrase(分式 4 分之 3)
  - x: "*[1]"
  - pause: short

- name: default
  tag: fraction
  match: "."
  replace:
  - test:
      if: "$Impairment = 'Blindness'"
      then: [T: "分式"]      # phrase('分式' 3 比上 4)
  - pause: short
  - x: "*[1]"
  - test:
      if: "not(IsNode(*[1],'leaf'))"
      then: [pause: short]
  - T: "比上"      # phrase(分式 3 '比上' 4)
  - test:
      if: "not(IsNode(*[2],'leaf'))"
      then: [pause: short]
  - x: "*[2]"
  - pause: short
  - test:
      if: "$Impairment = 'Blindness'"
      then: [T: "结束分式"]      # phrase(分式 7 比上 8 '结束分式')
  - pause: medium

# rules for functions raised to a power
# these could have been written on 'mrow' but putting them on msup seems more specific
# to see if it is a function, we look right to see if the following sibling is apply-function
- name: inverse-function
  tag: inverse-function
  match: "."
  replace:
  - T: "反"      # phrase('反' f)
  - x: "*[1]"

- name: function-squared-or-cubed
  tag: power
  match:
  - "*[2][self::m:mn][text()='2' or text()='3'] and"
  - "following-sibling::*[1][self::m:mo][text()='⁡']" #invisible function apply
  replace:
  - x: "*[1]"
  - bookmark: "*[2]/@id"
  - test:
      if: "*[2][text()=2]"
      then: [T: "平方"]      # phrase(5 '平方' 等于 25)
      else: [T: "立方"]      # phrase(5 '立方' 等于 125)
- name: function-power
  tag: power
  match:
  - "following-sibling::*[1][self::m:mo][text()='⁡']" #invisible function apply
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]      # phrase(f '的' 4 次方)
  - bookmark: "*[2]/@id"
  - x: "*[2]"
  - T: "次方"      # phrase(f 的 4 '次方')
  - pause: short

# non-function rules for power
- name: squared-or-cubed
  tag: power
  match: "*[2][self::m:mn][text()='2' or text()='3']"
  replace:
  - x: "*[1]"
  - bookmark: "*[2]/@id"
  - test:
      if: "*[2][text()=2]"
      then: [T: "的平方"]      # phrase(5 '的平方' 等于 25)
      else: [T: "的立方"]      # phrase(5 '的立方' 等于 125)

- name: simple-integer
  tag: power
  match: "*[2][self::m:mn][not(contains(., '.'))]"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]   # phrase(x '的' 4 次方)
  - x: "*[2]"
  - T: "次方"   # phrase(x 的 4 '次方')
- name: simple-negative-integer
  tag: power
  match:
  - "*[2][self::m:negative and"
  - "     *[1][self::m:mn][not(contains(., '.'))]]"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]   # phrase(x '的' 负 2 次方)
  - x: "*[2]"
  - T: "次方"   # phrase(x 的 负 2 '次方')

- name: simple-var
  tag: power
  match: "*[2][self::m:mi][string-length(.)=1]"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]   # phrase(x '的' n 次方)
  - x: "*[2]"
  - T: "次方"   # phrase(x 的 4 '次方')

- name: simple
  tag: power
  match: "IsNode(*[2], 'leaf')"
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]   # phrase(x '的' 2.0 次方)
  - x: "*[2]"
  - T: "次方"   # phrase(x 的 2.0 '次方')

- name: nested
  # it won't end in "power" if the exponent is simple enough
  # FIX: not that important, but this misses the case where the nested exp is a negative integer (change test if this is fixed)
  # ending nested exponents with "...power power" sounds bad
  tag: power
  match:
  - "*[2]["
  - "     (self::m:power and not(IsNode(*[2], 'leaf'))) or" # non-simple nested superscript
  - "     self::m:mrow[*[last()][self::m:power[not(IsNode(*[2], 'leaf'))]]]" # same as above but at the end of an mrow # FIX: need to figure out linear replacement
  - "    ]"
  replace:
  - x: "*[1]"
  - T: "的"      # phrase(t '的' 2 的 x +1 次方, 次方;)
  - x: "*[2]"
  - pause: short
  - T: "次方"      # phrase(t 的 2 的 x +1 次方, '次方';)
  - pause: medium

- name: default
  tag: power
  match: "."
  replace:
  - x: "*[1]"
  - test:
      if: "$Verbosity!='Terse'"
      then: [T: "的"]   # phrase(x '的' x 加 y 次方)
  - x: "*[2]"
  - T: "次方"   # phrase(x 的 x  加 y '次方')
  - pause: short

#
# Some rules on mrows
#
- name: set
  tag: set
  match: "."
  replace:
  - test:
    - if: "count(*)=0"
      then:
      - T: "空集"      # phrase('空集'是指不含任何元素的集合。)
    - else_if: "count(*[1]/*)=3 and *[1]/*[2][self::m:mo][text()=':' or text()='|' or text()='∣']"
      then:
      - T: "集合所有"      # phrase('集合所有' x 属于 正整数 满足 x 小于 10)
      - x: "*[1]/*[1]"
      - T: "满足"      # phrase(x '满足' x 小于 y)
      - x: "*[1]/*[3]"
      else:
      - T: "集合"      # phrase('集合'指若干不同元素形成的总体。)
      - x: "*[1]"

- name: times
  tag: mo
  match:
  # say "times" when invisible times is followed by parens or a superscript that has a base with parens or "|"s
  # if we aren't sure if it is times or not, don't say anything
  - "text()='⁢' and"
  - "not(@data-function-guess) and ("
  - "not(ancestor-or-self::*[contains(@data-intent-property, ':structure:')]) and "
  - "  following-sibling::*[1]["
  - "    IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|') or self::m:binomial or" # followed by parens
  - "    ( (self::m:msup or self::m:msub or self::m:msubsup or self::m:power) and " # followed by msup, etc.
  - "       *[1][self::m:mrow][IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')]" # base has parens
  - "    )"
  - "  ]"
  # other possibility is the preceding element has parens (but not the following)
  - " or "
  - "  preceding-sibling::*[1]["
  - "    IsBracketed(., '(', ')') or IsBracketed(., '[', ']') or IsBracketed(., '|', '|')]" # followed by parens
  - " )"
  replace:
  - T: "乘以"      # phrase(7 '乘以' 5 等于 35)

- name: no-say-parens
  tag: mrow
  match:
  - "parent::*[not(self::m:msup) and not(self::m:msub) and not(self::m:msubsup) and not(self::m:power) and"
  - "          not(self::m:math) ] and "       # rule out [x] standing alone
  - "( IsBracketed(., '(', ')') or IsBracketed(., '[', ']') ) and "
  - "( IsNode(*[2], 'simple')  ) and"
  - "not(ancestor-or-self::*[contains(@data-intent-property, ':structure:')])"
  # missing clause: 'a positive fraction that is spoken as an ordinal
  #   (either by the Ordinal preference or by the default rules_'
  replace:
  - x: "*[2]"

- include: "SharedRules/geometry.yaml"
- include: "SharedRules/linear-algebra.yaml"
- include: "SharedRules/general.yaml"
- include: "SharedRules/default.yaml"
